**QA Ltd Project 2 – MakeMeASinger - Singer Name and Genre Generator**

**Author – Vicky Rai**

**Contents**

Objective

Tech stack

Project Scope

My method to meet the objective

User stories

Project Architecture

CI pipeline

Project management

Risk assessment

Testing

Testing reports

Evidence Of Using Docker

Evidence Of Using Webhooks

Further analysis

Difficulties faced

Licence

Acknowledgements

**Objective**

To create an app that generates “Objects” upon a set of predefined rules. A service-orientated architecture will be used, with the app being composed of four services that work together. Service #1 is the front-end so will render Jinja2 templates and will communicate with the other three services. Service #2 and #3 will both generate a random object. Service #4 also creates and object but this object will be based upon the results of service #2 and #3 using some predefined rules.

**Tech Stack**

Trello Kanban Board

GitHub for Version Control

CI Server: Jenkins

Ansible for the Configuration Management

GCP virtual machines for the cloud server

Docker for containerisation

Docker Swarm for the orchestration tool

NGINX for the reverse proxy

**Project Scope**

A Trello Kanban board with full expansion on tasks needed to complete the project.

An application fully integrated using the Feature-Branch model into a Version Control System which will then be built through a CI server and deployed to a Google Cloud Platform (GCP) virtual machine.

If a change is made to a code base, then Webhooks should be used so that Jenkins recreates and redeploys the changed application.

The project must be deployed using containerisation and an orchestration tool, namely Docker Swarm.

**My Method To Meet The Objective**

Service #2 will generate a random first name and service #3 will generate a random last name for the singer. So, they both generate a random “Object”. Service #4 will also create an “Object” but this time it will be dependant upon the results of service #2 and #3 using predefined rules. The “Objects” created by service #4 will be genres of music allocated to the singers. What the genre is dependent upon the length of the full name generated by services #2 and #3. NOTE: on 05/05/2022 this approach was changed. Instead of the genre being dependent upon the length of the full name generated by services #2 and #3, the length of the first name and the length of the surname are compared with each other. This approach offers more flexibility rather than hardcoding the numbers as they would have been done in the original approach. There will be two different implementations and these will be swapped out for each other seamlessly, without disrupting the user experience.

**User Stories**

As a user, I would like to generate a random first name.

As a user, I would like to generate a random surname.

As a user I would like to see these names displayed.

As a user I would like to see the genre of music displayed.

As a user, I would like to see the genre of music displayed.

**Project Architecture – CI Pipeline**
![enter image description here](https://github.com/VickyKR37/MakeMeASinger/blob/dev/git-images/CI-Pipeline_Diagram.png)

**Project Management**

The project management tool that I used to track the progress of the project was Trello, specifically the Kanban Board. Here is a link to the board:
[Trello/Kanban Board](https://trello.com/invite/b/C12qZDxO/bf9092a5ee1b4ba13a2682b38b985450/qa-project-2)

The board was designed to move from left to right:

with the _backlog_ first, for things that were not urgent, but would be nice to add

to the _design_ list, which contains the ERD and the CI Pipeline diagram. The ERD was vital to complete first in order to model the minimal viable product (MVP) that is required.

I then had a _to do_ list for any miscellaneous but important tasks such as the risk assessment, which didn’t fit neatly into another category on the board.

Then came _user stories_. For every feature of the app, there is a user story which breaks down and prioritises what needs to be done for the MVP for the project. This forces the developer to always see things from the user point of view, putting user experience (UX) first.

Next was a _doing_ table to move any tasks that I was currently working on it to.

Then there was _testing._

Finally, there is _done_ for tasks which have been completed and features implemented and tested.
Here are dated images of the Trello/Kanban Board as the project progressed:
![From 03/05/2022](https://github.com/VickyKR37/MakeMeASinger/blob/dev/git-images/03_05_2022.png)
![From 04/05/2022](https://github.com/VickyKR37/MakeMeASinger/blob/dev/git-images/04_05_2022.png)
![From 05/05/2022](https://github.com/VickyKR37/MakeMeASinger/blob/dev/git-images/05_05_22.png)

**Risk Assessment**

![Risk Assessment](https://github.com/VickyKR37/MakeMeASinger/blob/dev/git-images/Risk-Assessment-05.05.22.png)

**Testing**

I am using Test Mocking for the front-end because I have not created a database for this project. Mocking will allow me to create some dummy data in order to test that the front end responds as is intended with that dummy data. I will be using requests_mock which allows me to mock multiple http requests within the same function.

The following image shows that I tested for Service #2:

![Testing for Service-2](https://github.com/VickyKR37/MakeMeASinger/blob/dev/git-images/testing_service_2.png)


The following image shows that I tested for Service #1:

![Testing Service-1](https://github.com/VickyKR37/MakeMeASinger/blob/dev/git-images/service-1-test-passed.png)

The following image shows the coverage report for the testing of service #1. It shows how much of my app was tested. This is a great amount of coverage with all the main parts of my app covered 100%:

![Service-1 Coverage Report](https://github.com/VickyKR37/MakeMeASinger/blob/dev/git-images/service-1-cov-rep.png)

The following image show Jenkins running the testing automatically, which is far more efficient then it being run manually:
![Jenkins Testing](https://github.com/VickyKR37/MakeMeASinger/blob/dev/git-images/jenkins-testing.png)

**Evidence Of Using Docker**

![Docker Compose Working](https://github.com/VickyKR37/MakeMeASinger/blob/dev/git-images/04_05-docker-compose-working.png)

![Docker Build Success](https://github.com/VickyKR37/MakeMeASinger/blob/dev/git-images/04_04_2022_docker_build_success.png)


**Evidence Of Using Webhooks**

![Webhook Evidence](https://github.com/VickyKR37/MakeMeASinger/blob/dev/git-images/webhook.png)

**Further Analysis**

Unfortunately, I ran out of time and could not complete this project fully. Time managemnet will be a focus when moving forward. 

**Licencing**

No licence.

**Acknowledgements**

I used the following three projects on GitHub for reference:

[GitHub - TheEarlOfGray/fantasy-weapon-creator](https://github.com/TheEarlOfGray/fantasy-weapon-creator)

[GitHub - VSacr1/Project_2_Example](https://github.com/VSacr1/Project_2_Example)

[https://github.com/VickyKR37/QALtd-QuidProQuoApp](https://github.com/VickyKR37/QALtd-QuidProQuoApp)

I used the following websites when writing my risk assessment:

[https://www.cimcor.com/blog/the-top-5-security-risks-in-docker-container-deployment](https://www.cimcor.com/blog/the-top-5-security-risks-in-docker-container-deployment)

[https://www.jenkins.io/security](https://www.jenkins.io/security)

[https://en.wikipedia.org/wiki/Cross-site_request_forgery#Client-side_safeguards](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Client-side_safeguards)
